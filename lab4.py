##############################
# APS106 Winter 2022 - Lab 4 #
##############################

import math

def heat_control_hysteresis_thresh(temp_measured, current_state, temp_desired, alpha):
    """
    (float, bool, float, float) -> bool
    
    Implement a hysteresis threshold to determine and return the
    next state of the heater using the current state, latest measurement,
    desired temperature, and hyteresis buffer range (+/- alpha). 
    
    >>> heat_control_hysteresis_thresh(33.2, True, 40.0, 5.0)
    True
    
    >>> heat_control_hysteresis_thresh(28.4, True, 27.5, 1.0)
    True
    
    >>> heat_control_hysteresis_thresh(50.6, True, 40.0, 10.0)
    False
    
    >>> heat_control_hysteresis_thresh(30.8, False, 40.0, 2.9)
    True
    """    
    
    # TODO Write your code here

    k = temp_desired - temp_measured
    if current_state == True:
        if k < -alpha:
            return False
        else:
            return True
    if current_state == False:
        if k > alpha:
            return True
        else:
            return False


def newton_raphson_sqrt(n, epsilon):
    """
    (float,float) -> float
    
    Calcualtes the square root of a number, n, using the Newton-Raphson method.
    Returned value is the square root of n within tolerance amount
    specified by epsilon.
    
    >>> newton_raphson_sqrt(4.0,0.001)
    2.0
    
    >>> newton_raphson_sqrt(2.0, 0.1)
    1.417

    """
    
    # TODO Write your code here
    k = n
    while abs(k**2-n) > epsilon:
        k = 0.5*(k + n / k)
    k = round(k, 3)
    return k



def get_sensor_measurement(t,c0,c1,c2,c3,c4):
    """
    (float,float,float,float,float,float) -> float
    
    Simulates a sensor value reading. The value returned by the 
    function is generated by from the following equation:
        
        s(t) = c0*t + c1*sqrt(t) + c2*sin(t) + c3*cos(8t) + c4
        
    where t, c0, c1, c2, c3, and c4 are parameters passed into the function.
    The returned value is rounded to 3 decimal points.
    
    DO NOT EDIT THIS FUNCTION
    """
    measurement = c0*t + c1*newton_raphson_sqrt(abs(t),0.0005) + c2*math.sin(t) + c3*math.cos(8*t) + c4
    return round(measurement,3)



def thresh_crossing_counter(temp_desired, hyst_alpha,
                            t_start,t_stop,
                            c0,c1,c2,c3,c4):
    """
    (float, float, float, float, float, float, float, float, float) -> int
    
    Counts the number of times a simulated sensor measurement crosses a 
    hysteresis threshold.
    
    >>> thresh_crossing_counter(0.0, 0.2, 0.0, 10.01, -0.1, 2.0, 10.0, -5.0, -1.0)
    10
    """
    t_step = 0.05 # amount to increment the time after each sensor reading
    
    # Initialize the state
    # simply compare to the desired temperature because we don't yet know
    # the current state to use the hysteresis threshold
    state = get_sensor_measurement(t_start,c0,c1,c2,c3,c4) <= temp_desired 
    
    # TODO Write your code to complete the function here
    cur_state = state
    count = 0
    t = t_start + t_step
    while t <= t_stop:
        temp = cur_state
        cur_state = heat_control_hysteresis_thresh(get_sensor_measurement(t,c0,c1,c2,c3,c4), cur_state, temp_desired, hyst_alpha)
        if cur_state != temp:
            count = count + 1
        t = t + t_step
    return count


if __name__ == '__main__':
    import doctest
    doctest.testmod()

